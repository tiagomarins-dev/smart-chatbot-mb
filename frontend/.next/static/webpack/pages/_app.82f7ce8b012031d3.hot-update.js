"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/_app",{

/***/ "./src/api/client.ts":
/*!***************************!*\
  !*** ./src/api/client.ts ***!
  \***************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ApiClient: function() { return /* binding */ ApiClient; },\n/* harmony export */   apiClient: function() { return /* binding */ apiClient; }\n/* harmony export */ });\nconst API_URL = \"http://localhost:9032/api\" || 0;\n/**\n * API client for making requests to the backend\n */ class ApiClient {\n    /**\n   * Set the authentication token\n   */ setToken(token) {\n        this.token = token;\n        // Store token in localStorage for persistence\n        if (true) {\n            localStorage.setItem(\"auth_token\", token);\n        }\n    }\n    /**\n   * Get the authentication token\n   */ getToken() {\n        // Try to get from instance, then from localStorage\n        if (!this.token && \"object\" !== \"undefined\") {\n            this.token = localStorage.getItem(\"auth_token\");\n        }\n        return this.token;\n    }\n    /**\n   * Clear the authentication token\n   */ clearToken() {\n        this.token = null;\n        if (true) {\n            localStorage.removeItem(\"auth_token\");\n        }\n    }\n    /**\n   * Make a GET request\n   */ async get(path, params) {\n        const url = new URL(\"\".concat(API_URL).concat(path));\n        // Add query parameters\n        if (params) {\n            Object.entries(params).forEach((param)=>{\n                let [key, value] = param;\n                if (value !== undefined && value !== null) {\n                    url.searchParams.append(key, String(value));\n                }\n            });\n        }\n        const response = await fetch(url.toString(), {\n            method: \"GET\",\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    /**\n   * Make a POST request\n   */ async post(path, data) {\n        const response = await fetch(\"\".concat(API_URL).concat(path), {\n            method: \"POST\",\n            headers: this.getHeaders(),\n            body: data ? JSON.stringify(data) : undefined\n        });\n        return this.handleResponse(response);\n    }\n    /**\n   * Make a PUT request\n   */ async put(path, data) {\n        // Log para debug\n        console.log(\"PUT request to: \".concat(API_URL).concat(path));\n        console.log(\"Data being sent:\", data);\n        console.log(\"JSON data:\", data ? JSON.stringify(data) : \"undefined\");\n        const response = await fetch(\"\".concat(API_URL).concat(path), {\n            method: \"PUT\",\n            headers: this.getHeaders(),\n            body: data ? JSON.stringify(data) : undefined\n        });\n        // Log para debug\n        console.log(\"Response status:\", response.status);\n        return this.handleResponse(response);\n    }\n    /**\n   * Make a DELETE request\n   */ async delete(path) {\n        const response = await fetch(\"\".concat(API_URL).concat(path), {\n            method: \"DELETE\",\n            headers: this.getHeaders()\n        });\n        return this.handleResponse(response);\n    }\n    /**\n   * Get headers for API requests\n   */ getHeaders() {\n        const headers = {\n            \"Content-Type\": \"application/json\"\n        };\n        const token = this.getToken();\n        if (token) {\n            headers[\"Authorization\"] = \"Bearer \".concat(token);\n        }\n        return headers;\n    }\n    /**\n   * Handle API response\n   */ async handleResponse(response) {\n        try {\n            // Log para debug\n            console.log(\"Response status before parsing:\", response.status);\n            const responseText = await response.text();\n            console.log(\"Response text:\", responseText);\n            // Parse texto para JSON\n            let data;\n            try {\n                data = JSON.parse(responseText);\n                console.log(\"Parsed data:\", data);\n            } catch (e) {\n                console.error(\"Error parsing JSON:\", e);\n                return {\n                    success: false,\n                    error: \"Invalid JSON response: \" + responseText.substring(0, 100) + \"...\",\n                    statusCode: response.status\n                };\n            }\n            // If the response is not in the expected format, normalize it\n            if (data.success === undefined) {\n                return {\n                    success: response.ok,\n                    data: response.ok ? data : undefined,\n                    error: response.ok ? undefined : data.message || \"Unknown error\",\n                    statusCode: response.status\n                };\n            }\n            return data;\n        } catch (e) {\n            console.error(\"Error in handleResponse:\", e);\n            return {\n                success: false,\n                error: \"Error processing response: \" + String(e),\n                statusCode: response.status || 500\n            };\n        }\n    }\n    constructor(){\n        this.token = null;\n    }\n}\n// Create a singleton instance\nconst apiClient = new ApiClient();\n/* harmony default export */ __webpack_exports__[\"default\"] = (apiClient);\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFTO2dCQUNURCxPQUFPLGdDQUFnQ3RCLE9BQU9xQjtnQkFDOUNJLFlBQVl4QixTQUFTZSxNQUFNLElBQUk7WUFDakM7UUFDRjtJQUNGOzthQW5LUXBDLFFBQXVCOztBQW9LakM7QUFFQSw4QkFBOEI7QUFDdkIsTUFBTWdELFlBQVksSUFBSWxELFlBQVk7QUFFekMsK0RBQWVrRCxTQUFTQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9hcGkvY2xpZW50LnRzPzU5NjUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBpUmVzcG9uc2UgfSBmcm9tICcuLi9pbnRlcmZhY2VzJztcblxuY29uc3QgQVBJX1VSTCA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgJ2h0dHA6Ly9sb2NhbGhvc3Q6OTAzMi9hcGknO1xuXG4vKipcbiAqIEFQSSBjbGllbnQgZm9yIG1ha2luZyByZXF1ZXN0cyB0byB0aGUgYmFja2VuZFxuICovXG5leHBvcnQgY2xhc3MgQXBpQ2xpZW50IHtcbiAgcHJpdmF0ZSB0b2tlbjogc3RyaW5nIHwgbnVsbCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgYXV0aGVudGljYXRpb24gdG9rZW5cbiAgICovXG4gIHNldFRva2VuKHRva2VuOiBzdHJpbmcpIHtcbiAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgXG4gICAgLy8gU3RvcmUgdG9rZW4gaW4gbG9jYWxTdG9yYWdlIGZvciBwZXJzaXN0ZW5jZVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2F1dGhfdG9rZW4nLCB0b2tlbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgYXV0aGVudGljYXRpb24gdG9rZW5cbiAgICovXG4gIGdldFRva2VuKCk6IHN0cmluZyB8IG51bGwge1xuICAgIC8vIFRyeSB0byBnZXQgZnJvbSBpbnN0YW5jZSwgdGhlbiBmcm9tIGxvY2FsU3RvcmFnZVxuICAgIGlmICghdGhpcy50b2tlbiAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgdGhpcy50b2tlbiA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKCdhdXRoX3Rva2VuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRva2VuO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIHRoZSBhdXRoZW50aWNhdGlvbiB0b2tlblxuICAgKi9cbiAgY2xlYXJUb2tlbigpIHtcbiAgICB0aGlzLnRva2VuID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKCdhdXRoX3Rva2VuJyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBHRVQgcmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgZ2V0PFQ+KHBhdGg6IHN0cmluZywgcGFyYW1zPzogUmVjb3JkPHN0cmluZywgYW55Pik6IFByb21pc2U8QXBpUmVzcG9uc2U8VD4+IHtcbiAgICBjb25zdCB1cmwgPSBuZXcgVVJMKGAke0FQSV9VUkx9JHtwYXRofWApO1xuICAgIFxuICAgIC8vIEFkZCBxdWVyeSBwYXJhbWV0ZXJzXG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgT2JqZWN0LmVudHJpZXMocGFyYW1zKS5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgdmFsdWUgIT09IG51bGwpIHtcbiAgICAgICAgICB1cmwuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwudG9TdHJpbmcoKSwge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycygpLFxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlPFQ+KHJlc3BvbnNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgUE9TVCByZXF1ZXN0XG4gICAqL1xuICBhc3luYyBwb3N0PFQ+KHBhdGg6IHN0cmluZywgZGF0YT86IGFueSk6IFByb21pc2U8QXBpUmVzcG9uc2U8VD4+IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKGAke0FQSV9VUkx9JHtwYXRofWAsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCksXG4gICAgICBib2R5OiBkYXRhID8gSlNPTi5zdHJpbmdpZnkoZGF0YSkgOiB1bmRlZmluZWQsXG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2U8VD4ocmVzcG9uc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSBQVVQgcmVxdWVzdFxuICAgKi9cbiAgYXN5bmMgcHV0PFQ+KHBhdGg6IHN0cmluZywgZGF0YT86IGFueSk6IFByb21pc2U8QXBpUmVzcG9uc2U8VD4+IHtcbiAgICAvLyBMb2cgcGFyYSBkZWJ1Z1xuICAgIGNvbnNvbGUubG9nKGBQVVQgcmVxdWVzdCB0bzogJHtBUElfVVJMfSR7cGF0aH1gKTtcbiAgICBjb25zb2xlLmxvZygnRGF0YSBiZWluZyBzZW50OicsIGRhdGEpO1xuICAgIGNvbnNvbGUubG9nKCdKU09OIGRhdGE6JywgZGF0YSA/IEpTT04uc3RyaW5naWZ5KGRhdGEpIDogJ3VuZGVmaW5lZCcpO1xuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goYCR7QVBJX1VSTH0ke3BhdGh9YCwge1xuICAgICAgbWV0aG9kOiAnUFVUJyxcbiAgICAgIGhlYWRlcnM6IHRoaXMuZ2V0SGVhZGVycygpLFxuICAgICAgYm9keTogZGF0YSA/IEpTT04uc3RyaW5naWZ5KGRhdGEpIDogdW5kZWZpbmVkLFxuICAgIH0pO1xuICAgIFxuICAgIC8vIExvZyBwYXJhIGRlYnVnXG4gICAgY29uc29sZS5sb2coJ1Jlc3BvbnNlIHN0YXR1czonLCByZXNwb25zZS5zdGF0dXMpO1xuICAgIFxuICAgIHJldHVybiB0aGlzLmhhbmRsZVJlc3BvbnNlPFQ+KHJlc3BvbnNlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgREVMRVRFIHJlcXVlc3RcbiAgICovXG4gIGFzeW5jIGRlbGV0ZTxUPihwYXRoOiBzdHJpbmcpOiBQcm9taXNlPEFwaVJlc3BvbnNlPFQ+PiB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChgJHtBUElfVVJMfSR7cGF0aH1gLCB7XG4gICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgaGVhZGVyczogdGhpcy5nZXRIZWFkZXJzKCksXG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHRoaXMuaGFuZGxlUmVzcG9uc2U8VD4ocmVzcG9uc2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBoZWFkZXJzIGZvciBBUEkgcmVxdWVzdHNcbiAgICovXG4gIHByaXZhdGUgZ2V0SGVhZGVycygpOiBIZWFkZXJzSW5pdCB7XG4gICAgY29uc3QgaGVhZGVyczogSGVhZGVyc0luaXQgPSB7XG4gICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgIH07XG4gICAgXG4gICAgY29uc3QgdG9rZW4gPSB0aGlzLmdldFRva2VuKCk7XG4gICAgaWYgKHRva2VuKSB7XG4gICAgICBoZWFkZXJzWydBdXRob3JpemF0aW9uJ10gPSBgQmVhcmVyICR7dG9rZW59YDtcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuIGhlYWRlcnM7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlIEFQSSByZXNwb25zZVxuICAgKi9cbiAgcHJpdmF0ZSBhc3luYyBoYW5kbGVSZXNwb25zZTxUPihyZXNwb25zZTogUmVzcG9uc2UpOiBQcm9taXNlPEFwaVJlc3BvbnNlPFQ+PiB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIExvZyBwYXJhIGRlYnVnXG4gICAgICBjb25zb2xlLmxvZygnUmVzcG9uc2Ugc3RhdHVzIGJlZm9yZSBwYXJzaW5nOicsIHJlc3BvbnNlLnN0YXR1cyk7XG4gICAgICBjb25zdCByZXNwb25zZVRleHQgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gICAgICBjb25zb2xlLmxvZygnUmVzcG9uc2UgdGV4dDonLCByZXNwb25zZVRleHQpO1xuICAgICAgXG4gICAgICAvLyBQYXJzZSB0ZXh0byBwYXJhIEpTT05cbiAgICAgIGxldCBkYXRhO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UocmVzcG9uc2VUZXh0KTtcbiAgICAgICAgY29uc29sZS5sb2coJ1BhcnNlZCBkYXRhOicsIGRhdGEpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIEpTT046JywgZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6ICdJbnZhbGlkIEpTT04gcmVzcG9uc2U6ICcgKyByZXNwb25zZVRleHQuc3Vic3RyaW5nKDAsIDEwMCkgKyAnLi4uJyxcbiAgICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgLy8gSWYgdGhlIHJlc3BvbnNlIGlzIG5vdCBpbiB0aGUgZXhwZWN0ZWQgZm9ybWF0LCBub3JtYWxpemUgaXRcbiAgICAgIGlmIChkYXRhLnN1Y2Nlc3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHN1Y2Nlc3M6IHJlc3BvbnNlLm9rLFxuICAgICAgICAgIGRhdGE6IHJlc3BvbnNlLm9rID8gZGF0YSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICBlcnJvcjogcmVzcG9uc2Uub2sgPyB1bmRlZmluZWQgOiBkYXRhLm1lc3NhZ2UgfHwgJ1Vua25vd24gZXJyb3InLFxuICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgaW4gaGFuZGxlUmVzcG9uc2U6JywgZSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgZXJyb3I6ICdFcnJvciBwcm9jZXNzaW5nIHJlc3BvbnNlOiAnICsgU3RyaW5nKGUpLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMgfHwgNTAwXG4gICAgICB9O1xuICAgIH1cbiAgfVxufVxuXG4vLyBDcmVhdGUgYSBzaW5nbGV0b24gaW5zdGFuY2VcbmV4cG9ydCBjb25zdCBhcGlDbGllbnQgPSBuZXcgQXBpQ2xpZW50KCk7XG5cbmV4cG9ydCBkZWZhdWx0IGFwaUNsaWVudDsiXSwibmFtZXMiOlsiQVBJX1VSTCIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiQXBpQ2xpZW50Iiwic2V0VG9rZW4iLCJ0b2tlbiIsImxvY2FsU3RvcmFnZSIsInNldEl0ZW0iLCJnZXRUb2tlbiIsImdldEl0ZW0iLCJjbGVhclRva2VuIiwicmVtb3ZlSXRlbSIsImdldCIsInBhdGgiLCJwYXJhbXMiLCJ1cmwiLCJVUkwiLCJPYmplY3QiLCJlbnRyaWVzIiwiZm9yRWFjaCIsImtleSIsInZhbHVlIiwidW5kZWZpbmVkIiwic2VhcmNoUGFyYW1zIiwiYXBwZW5kIiwiU3RyaW5nIiwicmVzcG9uc2UiLCJmZXRjaCIsInRvU3RyaW5nIiwibWV0aG9kIiwiaGVhZGVycyIsImdldEhlYWRlcnMiLCJoYW5kbGVSZXNwb25zZSIsInBvc3QiLCJkYXRhIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJwdXQiLCJjb25zb2xlIiwibG9nIiwic3RhdHVzIiwiZGVsZXRlIiwicmVzcG9uc2VUZXh0IiwidGV4dCIsInBhcnNlIiwiZSIsImVycm9yIiwic3VjY2VzcyIsInN1YnN0cmluZyIsInN0YXR1c0NvZGUiLCJvayIsIm1lc3NhZ2UiLCJhcGlDbGllbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/api/client.ts\n"));

/***/ })

});